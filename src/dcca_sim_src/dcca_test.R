library(DCCA)
library(forecast)
library(tidyverse)
library(gridExtra)
library(here)

# Functions -----------------------------------------------------------
# going to set up a simulation similar to the one Cody used in his paper
# will choose a initial level of SB that is some % of unfished, then randomly choose 
# a value of sigmaR. From there, will sample 50 years of dynamics. At the end, will test Spearman's
# and DCCA on the stock

BevHolt_sim <- function(Nsims, Nyears, SB0, depletion, R0, h, SPR0){
  # create matrix for results
  sb_sims <- r_sims <- matrix(NA, nrow = Nyears, ncol = Nsims)
  sim_info <- matrix(NA, nrow = Nsims, ncol = 1)
  
  # simulation
  for(i in 1:Nsims){
    # draw random variability for each simulation
    sigmaR <- sample(c(0.1, 0.3, 0.5, 0.7, 0.9), 1, replace = TRUE)
    # record sim info
    sim_info[i,1] <- sigmaR
    # sample spawning biomass values
    sb_sims[,i] <- runif(Nyears, min = depletion*SB0, max = SB0)
    r_sims[,i] <- (0.8*R0*h*sb_sims[,i])/(0.2*SPR0*R0*(1 - h) + (h - 0.2)*sb_sims[,i])*exp(rnorm(Nyears, 0, sigmaR) - (sigmaR^2)/2)
  }
  
  return(list(sb_sims, r_sims, sim_info))
}

# Ricker paramertization for simulations
Ricker_sim <- function(Nsims, Nyears, SB0, depletion, R0, h, S0){
  # create matrix for results
  sb_sims <- r_sims <- matrix(NA, nrow = Nyears, ncol = Nsims)
  sim_info <- matrix(NA, nrow = Nsims, ncol = 1)
  
  # simulation
  for(i in 1:Nsims){
    # draw random variability for each simulation
    sigmaR <- sample(c(0.1, 0.3, 0.5, 0.7, 0.9), 1, replace = TRUE)
    # record sim info
    sim_info[i,1] <- sigmaR
    # sample spawning biomass values
    sb_sims[,i] <- runif(Nyears, min = depletion*SB0, max = SB0)
    r_sims[,i] <- R0*(sb_sims[,i]/S0)*exp(log(5*h)*(1 - sb_sims[,i]/S0)/0.8)*exp(rnorm(Nyears, 0, sigmaR) - (sigmaR^2)/2)
  }
  
  return(list(sb_sims, r_sims, sim_info))
}

# Beverton-Holt where SB values are generated by a AR(1) process
BevHoltAR_sim <- function(Nsims, Nyears, SB0, depletion, R0, h, SPR0, arval){
  # create matrix for results
  sb_sims <- r_sims <- matrix(NA, nrow = Nyears, ncol = Nsims)
  sim_info <- matrix(NA, nrow = Nsims, ncol = 1)
  
  # simulation
  for(i in 1:Nsims){
    # draw random variability for each simulation
    sigmaR <- sample(c(0.1, 0.3, 0.5, 0.7, 0.9), 1, replace = TRUE)
    # record sim info
    sim_info[i,1] <- sigmaR
    # sample spawning biomass values
    sb_sims[,i] <- arima.sim(list(order = c(1,0,0), ar = arval), n = Nyears, rand.gen = rnorm, sd = 10) + depletion*SB0
    r_sims[,i] <- (0.8*R0*h*sb_sims[,i])/(0.2*SPR0*R0*(1 - h) + (h - 0.2)*sb_sims[,i])*exp(rnorm(Nyears, 0, sigmaR) - (sigmaR^2)/2)
  }
  
  return(list(sb_sims, r_sims, sim_info))
}
# Ricker where sb values are generated by an AR(1) function
RickerAR_sim <- function(Nsims, Nyears, SB0, depletion, R0, h, S0, arval){
  # create matrix for results
  sb_sims <- r_sims <- matrix(NA, nrow = Nyears, ncol = Nsims)
  sim_info <- matrix(NA, nrow = Nsims, ncol = 1)
  
  # simulation
  for(i in 1:Nsims){
    # draw random variability for each simulation
    sigmaR <- sample(c(0.1, 0.3, 0.5, 0.7, 0.9), 1, replace = TRUE)
    # record sim info
    sim_info[i,1] <- sigmaR
    # sample spawning biomass values
    sb_sims[,i] <- arima.sim(list(order = c(1,0,0), ar = arval), n = Nyears, rand.gen = rnorm, sd = 10) + depletion*SB0
    r_sims[,i] <- R0*(sb_sims[,i]/S0)*exp(log(5*h)*(1 - sb_sims[,i]/S0)/0.8)*exp(rnorm(Nyears, 0, sigmaR) - (sigmaR^2)/2)
  }
  
  return(list(sb_sims, r_sims, sim_info))
}

# calculate correlation coefficients for each method
get_corrs <- function(spawn, recruit, win_size, error, nu){
  
  # create matrix for results
  Nsims <- dim(spawn)[2]
  corr_df <- matrix(NA, nrow = Nsims, ncol = 2)
  
  # calculate correlation coefficients
  for(i in 1:Nsims){
    # spearman's correlation
    sp_rho <- cor.test(rank(recruit[,i]), rank(spawn[,i]))
    corr_df[i,1] <- sp_rho$estimate
    # dcca 
    dc_rho <- rhodcca(recruit[,i], spawn[,i], m = win_size, nu = nu)
    corr_df[i, 2] <- dc_rho$rhodcca
  }
  
  # create data frame
  corr_df <- tibble(sigmaR = as.vector(error),
                    spearman = corr_df[,1],
                    dcca = corr_df[,2])
  
  return(corr_df)
}


# Simulations -------------------------------------------------------------
# plot multiple simulations
deps <- c(0.1,0.5)
steepness <- c(0.3,0.5,0.7,0.9)
pdf("results/dcca_sim/corr_sims_boxplot.pdf")
for(i in deps){
  for(j in steepness){
    bh_sims <- BevHolt_sim(Nsims = 10000, Nyears = 50, SB0 = 150, depletion = i, R0 = 20, SPR0 = 3, h = j)
    r_sims <- Ricker_sim(Nsims = 10000, Nyears = 50, SB0 = 150, depletion = i, R0 = 20, h = j, S0 = 150)
    
    # extract data
    bh_sb <- bh_sims[[1]]
    bh_r <- bh_sims[[2]]
    bh_sigmaR <- bh_sims[[3]]
    
    r_sb <- r_sims[[1]]
    r_r <- r_sims[[2]]
    r_sigmaR <- r_sims[[3]]
    
    # calculate correlations
    bh_sim_corr <- get_corrs(spawn = bh_sb, recruit = bh_r, win_size = 15, nu = 2, error = bh_sigmaR)
    r_sim_corr <- get_corrs(spawn = r_sb, recruit = r_r, win_size = 15, error = r_sigmaR, nu = 2)
    
    # rearrange data for box plots
    bh_sim_corr <- bh_sim_corr %>% pivot_longer(!sigmaR, names_to = "method", values_to = "rho")
    bh_sim_corr$sigmaR <- as_factor(bh_sim_corr$sigmaR)
    
    r_sim_corr <- r_sim_corr %>% pivot_longer(!sigmaR, names_to = "method", values_to = "rho")
    r_sim_corr$sigmaR <- as_factor(r_sim_corr$sigmaR)
    
    
    # box plots
    a <- ggplot(data = bh_sim_corr) + 
      geom_boxplot(aes(x = sigmaR, y = rho, fill = method)) + 
      labs(title = "Simulated correlation values with BH curve", x = "Recruitment error", y = "Rho", 
           fill = "Correlation Method", subtitle = paste("depletion =", i, "steepness =", j, sep = " ")) +
      scale_fill_manual(values = natparks.pals("Banff")) +
      theme_minimal()
    b <- ggplot(data = r_sim_corr) + 
      geom_boxplot(aes(x = sigmaR, y = rho, fill = method)) + 
      labs(title = "Simulated correlation values with Ricker curve", x = "Recruitment error", y = "Rho", 
           fill = "Correlation Method", subtitle = paste("depletion =", i, "steepness =", j, sep = " ")) +
      scale_fill_manual(values = natparks.pals("Banff")) +
      theme_minimal()
    
    print(grid.arrange(a, b, nrow = 2))
    
  }
}
dev.off()


# AR Simulations ----------------------------------------------------------
deps <- c(0.1,0.5)
steepness <- c(0.3,0.5,0.7,0.9)
pdf(here("results/dcca_sim/AR_corr_sims_boxplot.pdf"))
for(i in deps){
  for(j in steepness){
    bh_sims <- BevHoltAR_sim(Nsims = 10000, Nyears = 50, SB0 = 150, depletion = i, R0 = 20, SPR0 = 3, h = j, arval = 0.7)
    r_sims <- RickerAR_sim(Nsims = 10000, Nyears = 50, SB0 = 150, depletion = i, R0 = 20, h = j, S0 = 150, arval = 0.7)
    
    # extract data
    bh_sb <- bh_sims[[1]]
    bh_r <- bh_sims[[2]]
    bh_sigmaR <- bh_sims[[3]]
    
    r_sb <- r_sims[[1]]
    r_r <- r_sims[[2]]
    r_sigmaR <- r_sims[[3]]
    
    # calculate correlations
    bh_sim_corr <- get_corrs(spawn = bh_sb, recruit = bh_r, win_size = 15, nu = 2, error = bh_sigmaR)
    r_sim_corr <- get_corrs(spawn = r_sb, recruit = r_r, win_size = 15, error = r_sigmaR, nu = 2)
    
    # rearrange data for box plots
    bh_sim_corr <- bh_sim_corr %>% pivot_longer(!sigmaR, names_to = "method", values_to = "rho")
    bh_sim_corr$sigmaR <- as_factor(bh_sim_corr$sigmaR)
    
    r_sim_corr <- r_sim_corr %>% pivot_longer(!sigmaR, names_to = "method", values_to = "rho")
    r_sim_corr$sigmaR <- as_factor(r_sim_corr$sigmaR)
    
    
    # box plots
    a <- ggplot(data = bh_sim_corr) + 
      geom_boxplot( aes(x = sigmaR, y = rho, fill = method)) + 
      labs(title = "Simulated correlation values with BH AR curve", x = "Recruitment error", y = "Rho", 
           fill = "Correlation Method", subtitle = paste("depletion =", i, "steepness =", j, sep = " ")) +
      scale_fill_manual(values = natparks.pals("Banff")) +
      theme_minimal()
    b <- ggplot(data = r_sim_corr) + 
      geom_boxplot(aes(x = sigmaR, y = rho, fill = method)) + 
      labs(title = "Simulated correlation values with AR Ricker curve", x = "Recruitment error", y = "Rho", 
           fill = "Correlation Method", subtitle = paste("depletion =", i, "steepness =", j, sep = " ")) +
      scale_fill_manual(values = natparks.pals("Banff")) +
      theme_minimal()
    
    print(grid.arrange(a, b, nrow = 2))
    
  }
}
dev.off()


# Regression analysis -------------------------------------------------------------
get_corrs_sig <- function(spawn, recruit, error, Nsims){
  
  # create matrix for results
  Nsims <- dim(spawn)[2]
  corr_df <- matrix(NA, nrow = Nsims, ncol = 3)
  
  # calculate correlation coefficients
  for(i in 1:Nsims){
    # spearman's correlation
    sp_rho <- cor.test(rank(recruit[,i]), rank(spawn[,i]))
    corr_df[i,1] <- sp_rho$estimate
    corr_df[i,2] <- sp_rho$p.value
    if(abs(sp_rho$p.value) <= 0.05){
      corr_df[i,3] <- 1
    }else{
      corr_df[i,3] <- 0
    }
  }
  
  # create data frame
  corr_df <- tibble(sigmaR = as.vector(error),
                    spearman = corr_df[,1],
                    spearman_pval = corr_df[,2],
                    sig_pval = corr_df[,3])
  
  return(corr_df)
}

## Steepness -------------------------------------------------------------------
steepness <- seq(0.3, 0.9, 0.1)
steepness_df <- matrix(NA, nrow = length(steepness)*5, ncol = 3)

for(i in 1:length(steepness)){
  bh_sims2 <- BevHoltAR_sim(Nsims = 10000, Nyears = 50, SB0 = 150, depletion = 0.5, 
                            R0 = 20, SPR0 = 3, h = steepness[i], arval = 0.7)
  
  # extract data
  bh_sb2 <- bh_sims2[[1]]
  bh_r2 <- bh_sims2[[2]]
  bh_sigmaR2 <- bh_sims2[[3]]
  
  # calculate correlations
  bh_sim_corr2 <- get_corrs_sig(spawn = bh_sb2, recruit = bh_r2, error = bh_sigmaR2, Nsims = 10000)
  # summarize percent detection
  a <- bh_sim_corr2 %>% group_by(sigmaR) %>% summarise(prop_correct = sum(sig_pval)/n())
  
  # add to dataframe
  steepness_df[(i*5 - 4):(i*5),1] <- rep(steepness[i],5)
  steepness_df[(i*5 - 4):(i*5),2] <- a$sigmaR
  steepness_df[(i*5 - 4):(i*5),3] <- a$prop_correct
}

steepness_df <- as_tibble(steepness_df)
colnames(steepness_df) <- c("steepness", "sigmaR", "detected")


pdf(here("results/dcca_sim/AR_BH_steepness_regression.pdf"))
print(ggplot(steepness_df) + geom_line(aes(x = sigmaR, y = detected, color = as.factor(steepness)), size = 1) +
  labs(x = "Recruitment error", y = "Percent detected", color = "Steepness", subtitle = "depletion = 0.5") +
  scale_color_manual(values = natparks.pals("Banff")) + theme_minimal())
dev.off()

## Depletion --------------------------------------------------------
deplet <- seq(0.2, 0.8, 0.1)
deplet_df <- matrix(NA, nrow = length(deplet)*5, ncol = 3)

for(i in 1:length(deplet)){
  bh_sims2 <- BevHoltAR_sim(Nsims = 10000, Nyears = 50, SB0 = 150, depletion = deplet[i], 
                            R0 = 20, SPR0 = 3, h = 0.5, arval = 0.7)
  
  # extract data
  bh_sb2 <- bh_sims2[[1]]
  bh_r2 <- bh_sims2[[2]]
  bh_sigmaR2 <- bh_sims2[[3]]
  
  # calculate correlations
  bh_sim_corr2 <- get_corrs_sig(spawn = bh_sb2, recruit = bh_r2, error = bh_sigmaR2, Nsims = 10000)
  # summarize percent detection
  a <- bh_sim_corr2 %>% group_by(sigmaR) %>% summarise(prop_correct = sum(sig_pval)/n())
  
  # add to dataframe
  deplet_df[(i*5 - 4):(i*5),1] <- rep(deplet[i],5)
  deplet_df[(i*5 - 4):(i*5),2] <- a$sigmaR
  deplet_df[(i*5 - 4):(i*5),3] <- a$prop_correct
}

deplet_df <- as_tibble(deplet_df)
colnames(deplet_df) <- c("depletion", "sigmaR", "detected")

pdf(here("results/dcca_sim/AR_BH_depletion_regression.pdf"))
print(ggplot(deplet_df) + geom_line(aes(x = sigmaR, y = detected, color = as.factor(depletion)), size = 1) +
        labs(x = "Recruitment error", y = "Percent detected", color = "Depletion", subtitle = "steepness = 0.5") +
        scale_color_manual(values = natparks.pals("Banff")) + theme_minimal())
dev.off()


# Window sensitivity test -------------------------------------------------
window_test_stocks <- rbind(env_driven_stocks, edge_stocks, sb_driven_stocks)
window_test_stocks$driver <- c(rep("environment", 244), rep("edge", 127), 
                               rep("spawning biomass", 61))
window_test_stocks$win5_rho <- rep(NA, nrow(window_test_stocks))
window_test_stocks$win10_rho <- rep(NA, nrow(window_test_stocks))
window_test_stocks$win15_rho <- rep(NA, nrow(window_test_stocks))
window_test_stocks <- window_test_stocks[,-c(3:10)]

window_size <- c(5, 10, 15)

for(i in 1:nrow(window_test_stocks)){
  for(j in 1:length(window_size)){
    # retrieve S-R data
    stock_name <- pull(window_test_stocks[i, "stock_name"])
    stock <- retrieve_sr_data(stock_name)
    
    # calculate dcca rho
    dc_cor <- rhodcca(stock$recruits, stock$sb, m = window_size[j], nu = 2)
    
    # save rho value
    if(j == 1){
      window_test_stocks[i, "win5_rho"] <- dc_cor$rhodcca
    } else if(j == 2){
      window_test_stocks[i, "win10_rho"] <- dc_cor$rhodcca
    } else{
      window_test_stocks[i, "win15_rho"] <- dc_cor$rhodcca
    }
  }
}


# plot results
window_test_stocks2 <- window_test_stocks %>% 
  pivot_longer(!c(stock_name, curve_shape, driver), names_to = "window_size", values_to = "dcca_rho")
window_test_stocks2$window_size[window_test_stocks2$window_size == "win5_rho"] <- 5
window_test_stocks2$window_size[window_test_stocks2$window_size == "win10_rho"] <- 10
window_test_stocks2$window_size[window_test_stocks2$window_size == "win15_rho"] <- 15

pdf(here("results/dcca_sim", "window_rho_sensitivity.pdf"))
aa <- ggplot(data = subset(window_test_stocks2, driver == "environment")) + 
  geom_density(aes(x = dcca_rho, fill = as.factor(window_size)), position = "identity", alpha = 0.5) +
  labs(x = "DCCA correlation coefficient", fill = "window size", subtitle = "(a)") +
  scale_fill_manual(values = c("#006475", "#586028", "#9DA7BF")) +
  theme_minimal()
bb <- ggplot(data = subset(window_test_stocks2, driver == "edge")) + 
  geom_density(aes(x = dcca_rho, fill = as.factor(window_size)), position = "identity", alpha = 0.5) +
  labs(x = "DCCA correlation coefficient", fill = "window size", subtitle = "(b)") +
  scale_fill_manual(values = c("#006475", "#586028", "#9DA7BF")) +
  theme_minimal()
cc <- ggplot(data = subset(window_test_stocks2, driver == "spawning biomass")) + 
  geom_density(aes(x = dcca_rho, fill = as.factor(window_size)), position = "identity", alpha = 0.5) +
  labs(x = "DCCA correlation coefficient", fill = "window size", subtitle = "(c)") +
  scale_fill_manual(values = c("#006475", "#586028", "#9DA7BF")) +
  theme_minimal()
print(grid.arrange(aa, bb, cc, nrow = 3))
dev.off()

# find max absolute rho value for each sample stock
rho_vals <- abs(window_test_stocks[,3:5])
win_max_rho <- colnames(rho_vals)[apply(rho_vals, 1, which.max)]
window_test_stocks$max_abs_rho <- win_max_rho

window_test_stocks %>% 
  group_by(driver, max_abs_rho) %>% 
  summarise(n = n())

window_test_stocks %>% 
  group_by(curve_shape, max_abs_rho) %>% 
  summarise(n = n())
